{"sections":[],"identifier":{"url":"doc:\/\/audiouiswift.AudioUI\/documentation\/AudioUI\/PerformanceOptimization","interfaceLanguage":"swift"},"kind":"article","abstract":[{"type":"text","text":"Advanced techniques and best practices for building high-performance audio interfaces with AudioUI that maintain smooth 60fps rendering and minimal CPU usage."}],"primaryContentSections":[{"content":[{"level":2,"type":"heading","text":"Overview","anchor":"Overview"},{"type":"paragraph","inlineContent":[{"text":"Audio applications demand exceptional performance. Users expect interfaces that respond immediately to gestures while background audio processing continues uninterrupted. AudioUI provides several optimization strategies to achieve professional-level performance.","type":"text"}]},{"level":2,"type":"heading","text":"Core Optimization Principles","anchor":"Core-Optimization-Principles"},{"level":3,"type":"heading","text":"Frame Rate Targets","anchor":"Frame-Rate-Targets"},{"type":"paragraph","inlineContent":[{"text":"AudioUI components are designed to maintain consistent frame rates:","type":"text"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"60 FPS","type":"text"}],"type":"strong"},{"type":"text","text":": Standard target for smooth UI interactions"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"120 FPS","type":"text"}]},{"type":"text","text":": ProMotion displays and high-refresh screens"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Real-time","type":"text"}],"type":"strong"},{"text":": Sub-frame timing for critical audio controls","type":"text"}]}]}]},{"level":3,"type":"heading","text":"Memory Management","anchor":"Memory-Management"},{"type":"paragraph","inlineContent":[{"text":"Efficient memory usage prevents audio dropouts:","type":"text"}]},{"code":["import AudioUI","","class OptimizedAudioInterface: ObservableObject {","    \/\/ Use @StateObject for expensive objects","    @StateObject private var audioEngine = AudioEngine()","    ","    \/\/ Reuse views instead of creating new ones","    private let knobPool = ComponentPool<InsetNeumorphicKnob>(capacity: 32)","    private let meterPool = ComponentPool<ThemedLevelMeter>(capacity: 16)","    ","    \/\/ Cache expensive calculations","    private var cachedSpectrumData: [Float] = []","    private var spectrumUpdateTimer: Timer?","    ","    func optimizedSetup() {","        \/\/ Batch updates to reduce redraws","        DispatchQueue.main.async {","            self.updateAllControls()","        }","        ","        \/\/ Use dedicated timer for real-time updates","        spectrumUpdateTimer = Timer.scheduledTimer(withTimeInterval: 1\/60) { _ in","            self.updateSpectrum()","        }","    }","}"],"type":"codeListing","syntax":"swift"},{"level":2,"type":"heading","text":"Component-Level Optimizations","anchor":"Component-Level-Optimizations"},{"level":3,"type":"heading","text":"Efficient Level Meters","anchor":"Efficient-Level-Meters"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Level meters update frequently and need careful optimization:"}]},{"code":["struct OptimizedLevelMeter: View {","    let level: Double","    let peak: Double","    ","    \/\/ Cache drawing data","    @State private var segments: [SegmentData] = []","    @State private var lastUpdateTime: CFAbsoluteTime = 0","    ","    var body: some View {","        Canvas { context, size in","            \/\/ Only redraw if values changed significantly","            let currentTime = CFAbsoluteTimeGetCurrent()","            guard currentTime - lastUpdateTime > 1\/120 else { return }","            ","            drawOptimizedMeter(context: context, size: size)","            lastUpdateTime = currentTime","        }","        .drawingGroup() \/\/ Composite into single layer","        .onChange(of: level) { newLevel in","            updateSegments(level: newLevel, peak: peak)","        }","    }","    ","    private func drawOptimizedMeter(context: GraphicsContext, size: CGSize) {","        \/\/ Use pre-calculated segment data","        for segment in segments {","            context.fill(","                Path(roundedRect: segment.rect, cornerRadius: 1),","                with: .color(segment.color)","            )","        }","    }","    ","    private func updateSegments(level: Double, peak: Double) {","        \/\/ Batch calculate all segments at once","        segments = SegmentCalculator.calculate(","            level: level,","            peak: peak,","            size: bounds.size","        )","    }","}"],"type":"codeListing","syntax":"swift"},{"level":3,"type":"heading","text":"Knob Optimization","anchor":"Knob-Optimization"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Reduce knob rendering overhead during rotation:"}]},{"code":["struct HighPerformanceKnob: View {","    @Binding var value: Double","    ","    \/\/ Pre-render static elements","    @State private var staticBackground: Image?","    @State private var rotationAngle: Angle = .zero","    ","    var body: some View {","        ZStack {","            \/\/ Static background (rendered once)","            if let background = staticBackground {","                background","            } else {","                KnobBackground()","                    .onAppear {","                        staticBackground = renderStaticBackground()","                    }","            }","            ","            \/\/ Only the thumb rotates","            KnobThumb()","                .rotationEffect(rotationAngle)","                .animation(.easeOut(duration: 0.05), value: rotationAngle)","        }","        .gesture(","            DragGesture(minimumDistance: 0)","                .onChanged { gesture in","                    \/\/ Direct angle calculation without intermediate updates","                    let angle = calculateAngle(from: gesture.location)","                    updateValue(from: angle)","                }","        )","        .onChange(of: value) { newValue in","            rotationAngle = angleForValue(newValue)","        }","    }","    ","    private func renderStaticBackground() -> Image {","        \/\/ Render background to bitmap once","        let renderer = ImageRenderer(content: KnobBackground())","        renderer.scale = UIScreen.main.scale","        return Image(uiImage: renderer.uiImage ?? UIImage())","    }","}"],"type":"codeListing","syntax":"swift"},{"level":2,"type":"heading","text":"Batch Updates and Timing","anchor":"Batch-Updates-and-Timing"},{"level":3,"type":"heading","text":"Efficient Multi-Channel Updates","anchor":"Efficient-Multi-Channel-Updates"},{"type":"paragraph","inlineContent":[{"text":"When updating many components simultaneously:","type":"text"}]},{"code":["class MixingConsoleManager: ObservableObject {","    @Published var channels: [ChannelData] = []","    ","    private var updateTimer: CADisplayLink?","    private var pendingUpdates: Set<Int> = []","    ","    func startRealTimeUpdates() {","        updateTimer = CADisplayLink(target: self, selector: #selector(updateChannels))","        updateTimer?.add(to: .main, forMode: .common)","    }","    ","    @objc private func updateChannels() {","        \/\/ Batch all updates into single UI refresh","        guard !pendingUpdates.isEmpty else { return }","        ","        let updatedChannels = channels","        for channelIndex in pendingUpdates {","            if channelIndex < updatedChannels.count {","                updatedChannels[channelIndex] = getLatestChannelData(channelIndex)","            }","        }","        ","        \/\/ Single update triggers all UI changes","        channels = updatedChannels","        pendingUpdates.removeAll()","    }","    ","    func markChannelForUpdate(_ index: Int) {","        pendingUpdates.insert(index)","    }","}"],"type":"codeListing","syntax":"swift"},{"level":3,"type":"heading","text":"Smart Update Scheduling","anchor":"Smart-Update-Scheduling"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Prioritize updates based on user interaction:"}]},{"code":["class SmartUpdateScheduler {","    private var highPriorityComponents: Set<ComponentID> = []","    private var normalPriorityComponents: Set<ComponentID> = []","    ","    func scheduleUpdate(for component: ComponentID, priority: UpdatePriority) {","        switch priority {","        case .high:","            highPriorityComponents.insert(component)","            scheduleImmediate()","        case .normal:","            normalPriorityComponents.insert(component)","            scheduleNextFrame()","        case .low:","            scheduleWhenIdle()","        }","    }","    ","    private func scheduleImmediate() {","        DispatchQueue.main.async {","            self.processHighPriorityUpdates()","        }","    }","    ","    private func scheduleNextFrame() {","        DispatchQueue.main.asyncAfter(deadline: .now() + 1\/60) {","            self.processNormalPriorityUpdates()","        }","    }","}"],"type":"codeListing","syntax":"swift"},{"level":2,"type":"heading","text":"Memory and Resource Management","anchor":"Memory-and-Resource-Management"},{"level":3,"type":"heading","text":"Component Pooling","anchor":"Component-Pooling"},{"type":"paragraph","inlineContent":[{"text":"Reuse expensive components instead of creating new ones:","type":"text"}]},{"code":["class ComponentPool<T: AudioUIComponent> {","    private var available: [T] = []","    private var inUse: [T] = []","    private let factory: () -> T","    ","    init(capacity: Int, factory: @escaping () -> T) {","        self.factory = factory","        for _ in 0..<capacity {","            available.append(factory())","        }","    }","    ","    func acquire() -> T {","        if let component = available.popLast() {","            inUse.append(component)","            return component","        } else {","            let component = factory()","            inUse.append(component)","            return component","        }","    }","    ","    func release(_ component: T) {","        if let index = inUse.firstIndex(where: { $0.id == component.id }) {","            inUse.remove(at: index)","            component.reset()  \/\/ Clear state","            available.append(component)","        }","    }","}"],"type":"codeListing","syntax":"swift"},{"level":3,"type":"heading","text":"Texture Management","anchor":"Texture-Management"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Efficient handling of visual resources:"}]},{"code":["class TextureManager {","    private static var shared = TextureManager()","    private var textureCache: [String: MTLTexture] = [:]","    ","    func texture(for key: String, generator: () -> MTLTexture) -> MTLTexture {","        if let cached = textureCache[key] {","            return cached","        }","        ","        let texture = generator()","        textureCache[key] = texture","        return texture","    }","    ","    func preloadCommonTextures() {","        \/\/ Load frequently used textures at startup","        _ = texture(for: \"knob_background\") {","            generateKnobBackgroundTexture()","        }","        ","        _ = texture(for: \"button_gradient\") {","            generateButtonGradientTexture()","        }","    }","    ","    func clearUnusedTextures() {","        \/\/ Periodically clean up unused textures","        let now = Date()","        textureCache = textureCache.filter { key, texture in","            texture.lastAccessTime.timeIntervalSince(now) < 30.0","        }","    }","}"],"type":"codeListing","syntax":"swift"},{"level":2,"type":"heading","text":"Real-Time Audio Considerations","anchor":"Real-Time-Audio-Considerations"},{"level":3,"type":"heading","text":"Thread Safety","anchor":"Thread-Safety"},{"type":"paragraph","inlineContent":[{"text":"Ensure UI updates don’t interfere with audio processing:","type":"text"}]},{"code":["class AudioSafeUIUpdater {","    private let audioQueue = DispatchQueue(","        label: \"audio.processing\",","        qos: .userInteractive","    )","    ","    private let uiQueue = DispatchQueue.main","    ","    func updateMeterValue(_ value: Float, for meterID: String) {","        \/\/ Audio thread provides the value","        audioQueue.async {","            let processedValue = self.processMeterValue(value)","            ","            \/\/ UI updates happen on main thread","            self.uiQueue.async {","                self.updateMeterDisplay(processedValue, for: meterID)","            }","        }","    }","    ","    private func processMeterValue(_ value: Float) -> Float {","        \/\/ Smooth the value to prevent jitter","        return smoothingFilter.process(value)","    }","}"],"type":"codeListing","syntax":"swift"},{"level":3,"type":"heading","text":"Non-Blocking Updates","anchor":"Non-Blocking-Updates"},{"type":"paragraph","inlineContent":[{"text":"Prevent UI updates from blocking audio processing:","type":"text"}]},{"code":["class NonBlockingMeterUpdater {","    private var latestValues: [String: Float] = [:]","    private var displayValues: [String: Float] = [:]","    private let updateLock = NSLock()","    ","    func setValue(_ value: Float, for meterID: String) {","        \/\/ Non-blocking write from audio thread","        if updateLock.try() {","            latestValues[meterID] = value","            updateLock.unlock()","        }","        \/\/ If lock fails, skip this update (audio continues)","    }","    ","    func updateDisplays() {","        \/\/ UI thread reads latest values","        updateLock.lock()","        let valuesToDisplay = latestValues","        latestValues.removeAll()","        updateLock.unlock()","        ","        \/\/ Update UI with batched values","        for (meterID, value) in valuesToDisplay {","            updateMeterDisplay(value, for: meterID)","        }","    }","}"],"type":"codeListing","syntax":"swift"},{"level":2,"type":"heading","text":"Profiling and Debugging","anchor":"Profiling-and-Debugging"},{"level":3,"type":"heading","text":"Performance Monitoring","anchor":"Performance-Monitoring"},{"type":"paragraph","inlineContent":[{"text":"Track performance metrics in real-time:","type":"text"}]},{"code":["class PerformanceMonitor {","    private var frameTime: CFAbsoluteTime = 0","    private var updateCounts: [String: Int] = [:]","    ","    func startFrameTimer() {","        frameTime = CFAbsoluteTimeGetCurrent()","    }","    ","    func endFrameTimer() {","        let elapsed = CFAbsoluteTimeGetCurrent() - frameTime","        let fps = 1.0 \/ elapsed","        ","        if fps < 55 { \/\/ Below 60fps threshold","            reportPerformanceIssue(fps: fps)","        }","    }","    ","    func trackUpdate(for component: String) {","        updateCounts[component, default: 0] += 1","    }","    ","    func generatePerformanceReport() -> PerformanceReport {","        return PerformanceReport(","            averageFPS: calculateAverageFPS(),","            updateFrequencies: updateCounts,","            memoryUsage: getCurrentMemoryUsage(),","            recommendations: generateOptimizationRecommendations()","        )","    }","}"],"type":"codeListing","syntax":"swift"},{"level":3,"type":"heading","text":"Optimization Tools","anchor":"Optimization-Tools"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Built-in tools to identify performance bottlenecks:"}]},{"code":["extension View {","    func performanceProfiled(_ identifier: String) -> some View {","        self.background(","            PerformanceProfiler(identifier: identifier)","        )","    }","}","","struct PerformanceProfiler: View {","    let identifier: String","    ","    var body: some View {","        EmptyView()","            .onAppear {","                PerformanceMonitor.shared.startProfiling(identifier)","            }","            .onDisappear {","                PerformanceMonitor.shared.endProfiling(identifier)","            }","    }","}","","\/\/ Usage","InsetNeumorphicKnob(value: $frequency)","    .performanceProfiled(\"FrequencyKnob\")"],"type":"codeListing","syntax":"swift"},{"level":2,"type":"heading","text":"Best Practices Summary","anchor":"Best-Practices-Summary"},{"level":3,"type":"heading","text":"Do’s","anchor":"Dos"},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Use "},{"type":"codeVoice","code":"drawingGroup()"},{"type":"text","text":" for complex visual compositions"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Cache expensive calculations and pre-render static content","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Batch UI updates to minimize redraw cycles"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Profile regularly and optimize bottlenecks","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"text","text":"Use component pooling for frequently created\/destroyed views"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Implement proper thread separation between audio and UI"}],"type":"paragraph"}]}]},{"level":3,"type":"heading","text":"Don’ts","anchor":"Donts"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"text","text":"Don’t update UI from audio processing threads"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Avoid creating new views on every frame"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"text","text":"Don’t perform expensive calculations in view bodies"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Avoid unnecessary precision in animations and updates","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"text":"Don’t block the main thread with heavy computations","type":"text"}]}]},{"content":[{"inlineContent":[{"text":"Avoid memory allocations in real-time update paths","type":"text"}],"type":"paragraph"}]}]},{"level":3,"type":"heading","text":"Performance Targets","anchor":"Performance-Targets"},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"UI Responsiveness","type":"text"}]},{"text":": < 16ms frame time (60 FPS)","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"inlineContent":[{"text":"Memory Usage","type":"text"}],"type":"strong"},{"text":": < 100MB for typical interfaces","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"CPU Usage","type":"text"}]},{"type":"text","text":": < 10% for UI rendering (leaving 90% for audio)"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Battery Life"}]},{"type":"text","text":": Minimal impact on device battery consumption"}]}]}]},{"type":"paragraph","inlineContent":[{"text":"Professional audio applications built with AudioUI achieve smooth, responsive interfaces that never interfere with audio processing, providing users with the reliable performance they expect from professional tools.","type":"text"}]}],"kind":"content"}],"metadata":{"title":"Performance Optimization","modules":[{"name":"AudioUI"}],"role":"collectionGroup"},"schemaVersion":{"major":0,"minor":3,"patch":0},"hierarchy":{"paths":[["doc:\/\/audiouiswift.AudioUI\/documentation\/AudioUI"],["doc:\/\/audiouiswift.AudioUI\/documentation\/AudioUI","doc:\/\/audiouiswift.AudioUI\/documentation\/AudioUI\/AudioUIMetalFX"]]},"seeAlsoSections":[{"anchor":"Performance--Platform","title":"Performance & Platform","generated":true,"identifiers":["doc:\/\/audiouiswift.AudioUI\/documentation\/AudioUI\/MetalEffects","doc:\/\/audiouiswift.AudioUI\/documentation\/AudioUI\/RealTimeAudio","doc:\/\/audiouiswift.AudioUI\/documentation\/AudioUI\/CrossPlatformConsiderations"]}],"variants":[{"paths":["\/documentation\/audioui\/performanceoptimization"],"traits":[{"interfaceLanguage":"swift"}]}],"references":{"doc://audiouiswift.AudioUI/documentation/AudioUI/AudioUIMetalFX":{"title":"AudioUIMetalFX","type":"topic","kind":"article","abstract":[{"text":"GPU-accelerated visual effects and real-time graphics processing for audio interfaces.","type":"text"}],"identifier":"doc:\/\/audiouiswift.AudioUI\/documentation\/AudioUI\/AudioUIMetalFX","url":"\/documentation\/audioui\/audiouimetalfx","role":"collectionGroup"},"doc://audiouiswift.AudioUI/documentation/AudioUI/RealTimeAudio":{"identifier":"doc:\/\/audiouiswift.AudioUI\/documentation\/AudioUI\/RealTimeAudio","abstract":[{"type":"text","text":"Design AudioUI interfaces that respond seamlessly to live audio processing while maintaining professional performance standards."}],"kind":"article","url":"\/documentation\/audioui\/realtimeaudio","type":"topic","title":"Real-Time Audio","role":"collectionGroup"},"doc://audiouiswift.AudioUI/documentation/AudioUI/CrossPlatformConsiderations":{"title":"Cross-Platform Considerations","type":"topic","role":"article","kind":"article","abstract":[{"type":"text","text":"Building audio interfaces that work seamlessly across iOS, macOS, and beyond."}],"url":"\/documentation\/audioui\/crossplatformconsiderations","identifier":"doc:\/\/audiouiswift.AudioUI\/documentation\/AudioUI\/CrossPlatformConsiderations"},"doc://audiouiswift.AudioUI/documentation/AudioUI/MetalEffects":{"identifier":"doc:\/\/audiouiswift.AudioUI\/documentation\/AudioUI\/MetalEffects","type":"topic","role":"collectionGroup","title":"Metal Effects","abstract":[{"type":"text","text":"Leverage GPU acceleration to create stunning real-time visual effects for advanced audio applications using AudioUI’s Metal-powered rendering system."}],"url":"\/documentation\/audioui\/metaleffects","kind":"article"},"doc://audiouiswift.AudioUI/documentation/AudioUI":{"kind":"symbol","abstract":[{"type":"text","text":"The ultimate SwiftUI framework for professional audio interface development."}],"identifier":"doc:\/\/audiouiswift.AudioUI\/documentation\/AudioUI","role":"collection","type":"topic","title":"AudioUI","url":"\/documentation\/audioui"}}}